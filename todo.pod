=head1 TO DO

=head2 Name

* Come up with a good name

* YODA (from the image in the talk)?

* "Answers you seek?"

=head2 Distribution

=head3 Docker

* ulimit for crawling processes

=head3 Windows distribution

* C<.msi> package including Perl, Apache Tika and Elasticsearch

* Debian package

=head2 Pages

=head3 Grid / Layout

The pages should use L<Dancer::Layout::Bootstrap>, or at least
an upgraded version of that.

=head3 C<robots.txt>

The app should prevent being spidered itself by always providing an
automatic C<robots.txt> that allows only C</about> and maybe C</> without
any parameters to be spidered.

This is somewhat ironic as the scrapers currently don't respect any
C<robots.txt> yet.

=head3 Search page

* Simple search

* Autocomplete/recommend

=head3 Simple (HTML) Results page

* Search images

=head3 Result fragment / document rendering

Come up with a concept to render different mime types differently.

Ideally, this would avoid the hardcoding we use for C<< audio/mpeg >>
currently.

This also entails information about things that are not files. Ideally,
we can render information about a "person" using a different template
as well, even though a "person" does not have a mime type associated with it.

=head3 Customization

* Auto-session

* Refinement using the last search, if the last search was "recently"

=head2 Plack

* L<Plack>-hook/example for C</search> to tie up the search application
into arbitrary websites

=head2 Dancer

* ElasticSearch plugin / configuration through YAML

* Upgrade to Dancer 2

=head2 Mojolicious

* ElasticSearch plugin / configuration through YAML

=head2 Search multiple indices

Having different Elasticsearch clusters available (or not) should
be recognized and the search results should be combined. For example,
a work cluster should be searched in addition to the local cluster, if the
work network is available.

This calls for using the asynchronous API not only for searching but also
for progressively enhancing the results page as new results become available.

=head2 Recognizing new versions of old documents

How can we/Elasticsearch recognize similarity between two documents?

If two documents live in the same directory, the newest one should take
precedence and fold the similar documents below it.

=head2 Java ES plugins

Currently better written in Perl

=head2 ES Analyzers

=head3 FS scanner

* Don't rescan/reanalyze elements that already exist in Elasticsearch

* Delete entries that don't exist in the filesystem anymore

=head3 Video data

Which module provides interesting video metadata?

=head3 Audio data

* MP3s get imported but could use a nicer body rendering.

* Playback duration should be calculated

* Also import audio lyrics - how could these be linked to their mp3s?

=head3 Playlist data

Playlists should get custom rendering (album art etc.)

Playlists should ideally also hotlink their contents

=head2 Test data

* Consider importing a Wikipedia dump

* Some other larger, mixed corpus, like http://eur-lex.europa.eu/

=head2 Synonyms

Find out which one(s) we want:

L<https://www.elastic.co/guide/en/elasticsearch/guide/current/synonyms-expand-or-contract.html>

From first glance, we might want Simple Expansion, but Genre Expansion
also seems interesting.

We want to treat some synonyms as identical though, like 'MMSR' and its
German translation 'Geldmarktstatistik'.

=head1 User Introduction

=head2 Videos

* Create screencasts using L<http://www.openshot.org/videos/> or

=head1 Code structure

=head2 Crawlers

=head3 File system crawler

Don't import hidden files by default

=head3 DBI crawler

Show example C<SELECT> statement

  SELECT
      product_name as title
    , 'http://productserver.internal/product/' || convert(varchar,product.id) as url
    , product_description as content
  FROM products

=head3 Create Dancer-crawler

Skip the HTTP generation process
and reuse C<App::Wallflower> for crawling a Dancer website.

=head3 Create tree-structure-importer

Both IMAP and file systems are basically directed graphs and far easier
to crawl than the cyclic graphs of web pages. Abstract out the crawling
of a tree into a common module.

* Turn C<index-imap> and C<index-filesystem> into modules so they
become independent of being called from an outside shell.

This also implies they become runnable directly from the web interface
without an intermediate shell.

* Add attachment import to the imap crawler

=head3 Calendar crawler

=head3 CardDAV crawler

To pull in information about people you know

=head3 Xing / LinkedIn / Facebook / Google+ crawler

To pull in information about people you know

=head3 LDAP crawler

To pull in information about people you know

=head2 Metasearch

Implement metasearch across multiple ES instances

=head1 Search index structure / data structures

=head2 Elasticsearch index

=head3 Last-verified field

We want a field to store when we last visited an URL so we
don't always reindex files with every run.

=head2 Crawl queue(s)

We want to have queues in which we store URLs to be crawled
to allow for asynchronous submission of new items. This also
allows us to be rate limited and restartable.

This could be an SQLite database, or just a flat text
file if we have a way to store the last position within that text
file.

=head2 SQL-index into filesystem

Is there any use in reviving FFRIndex?

=head1 System integration

Automatically (re)scan resources by using a notification
method like the following to be notified about new or changed
resources.

=head2 Resource modification

=head3 Filesystem watchers

=head3 RSS scanner

=head3 Google Sitemap scanner


=head2 Automatic search

Automatic search should be triggered for incoming phone calls. This
allows to automatically show relevant emails if the sender is calling
and has their phone information in their email.

Also, the automatic search should be easily triggered by a command
line program. This likely needs something like L<HTTP::ServerEvent>
to keep a channel open so the server can push new information.

=head1 Data portability

Data portability is very important, not at least because of
seamless index upgrades/rollbacks/backups.

=head2 Export

=head3 Export index to DBI

=head3 Update indices from database

=head2 Share indices

Sharing indices would also be nice in the sense of websites or people
offering datasets

=head2 DBI connectivity

How can we get L<DBI> and L<Promises> work nicely together?

=head3 Schema migration/update via DBI

=head3 DBI import queue

New items to be imported into Elasticsearch could be stored/read from
a DBI table. This would allow for a wider distributed set of crawlers
feeding through DBI to Elasticsearch.

=head1 First Start Experience

=head2 File system crawler

=head3 Windows

Use C<$ENV{USERPROFILE}>

=head3 Unixish

Use C<$ENV{HOME}>

=cut